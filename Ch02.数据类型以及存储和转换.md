# Ch02.数据类型以及存储和转换
## 一、数据类型分类
1. 基本（原始）类型：Number String Boolean Null Undefined
2. 引用（对象）类型：Object（Array、Function、Date等）
3. 判断数据类型（js中的一个重点）
* （typeof操作符：typeof operand  or  typeof (operand)）
4. 返回一个字符串，表示未经计算的操作数的类型。
* Undefined , Boolean , Number , String , 函数对象能唯一地被检测出操作时的类型
5. 如何区分Date、Array等对象？
6. 数据、变量和类型
（1）JavaScript中的变量没有类型</br>
（2）JavaScript中的数据值有类型</br>
（3）变量可以随时持有任何类型的值
* 在对变量执行 typeof 操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型。

## 二、数据类型存储（重点：基本数据类型和引用数据类型的存储）
1. 变量与内存
* 标识符：用于引用计算机内存的地址
* 变量声明：指向一块内存空间，用于保存数据
* 变量赋值：向变量指向的内存空间中存放数据
2. 内存空间的划分
（1）栈内存
①存储的值大小固定</br>
②由系统自动分配内存空间</br>
③空间小，运行效率高
（2）堆内存
①存储的值大小不定，可以动态调整</br>
②由程序员通过代码进行分配</br>
③空间大，运行效率相对比较低
3. 基本数据类型的存储
* 基本类型的变量是存放在栈区的，基本类型的值是不可变的
4. 引用数据类型的存储（重点）
* 引用类型的值是同时保存在栈内存和堆内存中的对象
（eg：var b={x:10}; 其中变量b存储于栈中，{x:10}作为对象存储在堆中）
* 引用类型的值是可变的。（栈区里存放的地址没有改变，但是堆区里的数据改变了）
5. 基本类型和引用类型存储的区别
（1）访问机制不同
①基本类型的值直接访问；</br>
②引用类型的值通过引用访问，不能直接访问（先从栈中获得该对象的地址引用，再从堆内存中取得需要的数据）
（2）复制变量不同
①基本类型复制：相互独立不影响</br>
②引用类型的复制：复制后地址指向的是同一个堆区，如果对象中数据改变，两个变量对应的数据都改变
（3）比较变量不同
①基本类型的比较：（值比较）判断变量的值是否相等</br>
②引用类型的比较：（引用比较）判断所指向的内存空间（地址）是否相同
（4）参数传递不同（ES中所有函数的参数都是按值来传递的）
①基本类型值：把变量里的数据值传递给参数，之后参数和变量互不影响</br>
②引用类型值：把对象引用（地址）值传递给参数，参数和对象都指向同一个对象，相互影响

## 三、数据类型转换->将值从一种类型转换为另一种类型
Ⅰ、隐式类型转换：字符串的拼接（+）；加上一个空字符串；变量*1->转换成Number类型 等等</br>
Ⅱ、显式类型转换：（强制转换）Boolean (a) ; String (b) 等等
* PS: 对于NaN的认识（not a number）
①表示一个不正确、没有意义的数值，与任何数做算数运算结果都是NaN</br>
②console.log(typeof NaN);   Number</br>
③NaN≠NaN</br>
④undefined在做算数运算时转换为Number类型，此时为NaN
* Eg：console.log(1+undefined); // 相当于转换成 1+NaN，得到结果仍然是NaN
⑤isNaN( ) 函数：用来检测参数是否为NaN值：是->返回true；不是->返回false
* Eg：isNaN(“123abc”) —> true
1. ->Number
①undefined->NaN</br>
②null->0</br>
③false->0  true->1</br>
④字符串:
* 解析字符串中的数字（忽略开头和结尾的空格）‘123’->123
* 字母和数字混杂 1a2b->NaN
⑤强制转换成Number类型：parseInt( )  parseFloat( )  Number( )</br>
⑥转换成Number类型最简单的方法是：a*1
2. ->String
①均转换成带引号的形式</br>
②强制转换：String( )</br>
③+运算符左右两侧有字符串的时候为拼接运算符，
* 转换成String类型最简单的方式是 +“”，eg：
3. ->Boolean
①undefined，null，0，NaN，空字符串->false</br>
②非零数字，非空字符串->true</br>
③强制转换：Boolean( )</br>
④逻辑运算符会将数据类型转换为布尔类型之后再做运算（一种隐式转换）
* 最方便得到布尔类型的方法：两次取非（！！）
